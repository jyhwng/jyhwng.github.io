{"componentChunkName":"component---src-templates-blog-post-js","path":"/callback","webpackCompilationHash":"36462b6fae656ae36777","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://g.co/kgs/AkNCEg\">자바스크립트 코딩 기법과 핵심 패턴(2011)</a> 책을 읽고 정리한 글입니다.</p>\n<p>👉 <a href=\"/literals-and-constructors\">3장 - Literals and Constructors</a></p>\n<hr>\n<h2>1. 콜백이란?</h2>\n<p>함수는 일급 객체다. 프로퍼티를 가질 수 있고, 변수에 할당할 수도 있고, 다른 함수에 인자로 전달할 수도 있다. 인자가 되는 함수를 <strong>콜백함수</strong>, 또는 <strong>콜백</strong> 이라고 부른다.</p>\n<blockquote>\n<p>명시적으로 호출하는 함수가 아니라 함수를 일단 등록하고, 특정 이벤트가 발생하거나 특정 시점에 도달했을 때 호출되는 함수이다. 또는 특정 함수의 인자로 넘겨서 코드 내부에서 호출되는 함수도 콜백함수라고 한다. 대표적인 콜백 함수가 자바스크립트에서 event handler이다. - 인사이드 자바스크립트(2016)</p>\n</blockquote>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">function writeCode(callback) {\n    // ...\n    callback()\n    // ...\n}\n\nfunction introduceBugs() {\n    // ...\n}\n\nwriteCode(introduceBugs)</code></pre>\n      </div>\n<ul>\n<li>함수의 <code class=\"language-text\">()</code>를 붙이면 즉시 실행, 붙이지 않으면 참조만 하고, 바깥 함수에서 알맞은 때에 실행해준다.</li>\n</ul>\n<hr>\n<h2>2. 콜백 예제</h2>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">// 콜백 없이 사용\n// array인 nodes를 인자로 받는 함수에서 nodes를 리턴하는 함수를 불러온다.\nlet findNodes = function() {\n    const i = 100000,\n            nodes = [],\n            found\n    while (i) {\n        // 노드를 수정하는 로직 - 따로 둔다.\n        nodes.push(found)\n    }\n    return nodes    // nodes 리턴\n}\n\nlet hide = function(nodes) {    // nodes를 인자로 받음\n    let i = 0,\n    max = nodes.length\n    for (i &lt; max; i += 1) {\n        nodes[i].style.display = &#39;none&#39;\n    }\n}\n\n// 함수 실행\nhide(findNodes())</code></pre>\n      </div>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">//  콜백으로 리팩토링\nlet findNodes = function (callback) {\n    const i = 100000,\n    nodes = [],\n    found\n\n    if (typeof callback !== &quot;function&quot;) {\n        callback = false\n    }\n\n    while (i) {\n        i -= 1\n        // 노드 수정 로직\n\n        if (callback) {\n            callback(found)\n        }\n\n        nodes.push(found)\n    }\n    return nodes\n}\n\n// 콜백 함수\nlet hide = function(node) {\n    node.style.display = &#39;none&#39;\n}\nfindNodes(hide)</code></pre>\n      </div>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">// hide()를 정의하지 않고 이렇게 익명함수로 표현할 수도 있다.\nfindNodes(function(node) {\n    node.style.display = &#39;none&#39;\n})</code></pre>\n      </div>\n<hr>\n<h2>3. 콜백과 유효범위</h2>\n<p>만약 콜백함수가 객체의 메서드인 경우, 콜백이 속한 객체를 바라보는 this를 사용하고 있을 때 문제가 된다.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">let myapp = {}\nmyapp.color = &#39;green&#39;\nmyapp.paint = function(node) {\n    node.style.color = this.color\n}\n\nfindNodes(myapp.paint)  // 객체의 메서드를 콜백함수로 가진다. myapp.paint 내 this는 findNodes에서 바라보는 객체를 가리킬 것이다.</code></pre>\n      </div>\n<ol>\n<li>이럴 경우, 아래처럼 콜백이 속해있는 객체도 인자로 받을 수 있도록 findNodes()를 수정해준다.</li>\n</ol>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">findNodes(myapp.paint, myapp)\n\nlet findNodes = function(cbMethod, cbObject) {\n    if (typeof cbMethod === &quot;function&quot;) {\n        cbMethod.call(cbObject, found)\n    }\n}</code></pre>\n      </div>\n<ol start=\"2\">\n<li>메서드를 문자열로 전달할 수도 있다.</li>\n</ol>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">findNodes(&quot;paint&quot;, myapp)\n\nlet findNodes = function(cbMethod, cbObject) {\n    if (typeof cbMethod === &quot;string&quot;) {\n        cbMethod = cbObject[cbMethod]\n    }\n    //\n    if (typeof cbMethod === &quot;function&quot;) {\n        cbMethod.call(cbObject, found)\n    }\n }</code></pre>\n      </div>\n<hr>\n<h2>4. 비동기 이벤트 리스너</h2>\n<p>페이지 element에 이벤트 리스너를 붙이는 것은 사실, 이벤트가 발생했을 때, 호출될 콜백함수의 포인터를 전달하는 것이다.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">document.addEventListener(&quot;click&quot;, console.log, false)</code></pre>\n      </div>\n<p>대부분의 클라이언트 브라우저 프로그래밍은 event-driven 방식이다. 자바스크립트가 event-driven 프로그래밍에 적합한 이유는 프로그램이 비동기적으로 동작할 수 있게 하는 콜백 패턴 덕분이다.</p>\n<hr>\n<h2>5. 타임아웃</h2>\n<p><code class=\"language-text\">setTimeout</code>과 <code class=\"language-text\">setInterval</code>도 대표적인 콜백 패턴이다.</p>\n<div class=\"gatsby-highlight\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\">let thePlotThickens = function() {\n    console.log(&#39;500ms later...&#39;);\n}\nsetTimeout(thePlotThickens, 500)</code></pre>\n      </div>\n<p>여기서 <code class=\"language-text\">thePlotThickens</code>가 ()없이 전달되었다. 즉시 실행하지 않고 500ms가 지난 후에 호출할 수 있도록 함수를 가리키고만 있는 것이다. 여기서 <code class=\"language-text\">&quot;thePlotThickens()&quot;</code>와 같이 문자열을 전달하는 건 eval()과 같은 안티패턴이다.</p>\n<hr>\n<h2>6. 라이브러리에서의 콜백</h2>\n<p>콜백패턴은 라이브러리를 설계할 때 매우 유용하고 강력하다. 라이브러리에 들어갈 코드는 최대한 범용적이고 재사용 가능해야 하기 때문에 연결고리만을 제공하는 콜백 패턴은 OCP 원칙에 입각한 프로그래밍을 할 수 있다.</p>","frontmatter":{"title":"Callback Pattern","date":"2017-11-15","path":"/callback","tags":["Javascript"],"excerpt":"Javascript Patterns(2011)"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}